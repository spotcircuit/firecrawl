<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Adjustable 4-corner overlay + optimal circle</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet/dist/leaflet.css"
  />
  <style>
    #map { width:  100%; height: 100vh; }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Leaflet -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <!-- smallest-enclosing-circle algorithm -->
  <script src="https://unpkg.com/smallest-enclosing-circle/dist/smallest-enclosing-circle.min.js"></script>
  <script>
    // 1. Initialize map
    const map = L.map('map').setView([39.0, -94.6], 11);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
      attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    // 2. Create 4 draggable corner-markers (start as a roughly rectangular area)
    const corners = [
      L.marker([39.15, -94.80], { draggable: true }).addTo(map),
      L.marker([39.15, -94.30], { draggable: true }).addTo(map),
      L.marker([38.80, -94.30], { draggable: true }).addTo(map),
      L.marker([38.80, -94.80], { draggable: true }).addTo(map),
    ];

    // 3. A polygon overlay to show the quadrilateral
    const quad = L.polygon(corners.map(m => m.getLatLng()), {
      color: 'blue', weight: 2, fillOpacity: 0.05
    }).addTo(map);

    // 4. A circle for the “optimal” inscribed/bounding circle
    let circ = L.circle([0,0], { radius: 0, color: 'red', weight: 2 }).addTo(map);

    // 5. Recompute on any drag
    corners.forEach(marker => marker.on('drag', updateOverlay));

    function updateOverlay() {
      // 5a. Update polygon
      const pts = corners.map(m => m.getLatLng());
      quad.setLatLngs(pts);

      // 5b. Compute the minimal enclosing circle (smallest circle containing all 4 points)
      //    `points` must be an array of [x, y] in Cartesian – but our points are lat/lng.
      //    For small areas we can treat lat→y, lng→x directly (approximation).
      const cart = pts.map(p => [p.lng, p.lat]);
      const mec = circleEnclose(cart); // from smallest-enclosing-circle

      // 5c. Convert back to Leaflet lat/lng and radius (in meters)
      const center = L.latLng(mec.y, mec.x);
      // estimate meters-per-degree latitude (~111.32km per degree), adjust for longitude by cos(lat)
      const metersPerDegLat = 111320;
      const metersPerDegLng = 40075000 * Math.cos(center.lat * Math.PI/180) / 360;
      // average scale for radius:
      const avgScale = (metersPerDegLat + metersPerDegLng)/2;
      const radiusMeters = mec.r * avgScale;

      circ.setLatLng(center).setRadius(radiusMeters);
    }

    // initial draw
    updateOverlay();
  </script>
</body>
</html>

